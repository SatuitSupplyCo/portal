name: Deploy Portal

on:
  push:
    branches: [main]
    paths:
      - "apps/portal/**"
      - "packages/**"
      - "pnpm-lock.yaml"
      - ".github/workflows/deploy-portal.yml"
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: 126710469812.dkr.ecr.us-east-1.amazonaws.com
  ECR_REPOSITORY: satuit/portal
  ECS_CLUSTER: satuit-prod
  ECS_SERVICE: portal
  CONTAINER_NAME: portal

jobs:
  build-and-push:
    name: Build & Push Image
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.meta.outputs.tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (shared-services)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::126710469812:role/gha-ecr-push
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        id: ecr-login
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set image tag
        id: meta
        run: echo "tag=sha-${GITHUB_SHA::8}" >> "$GITHUB_OUTPUT"

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: apps/portal/Dockerfile
          push: true
          tags: |
            ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ steps.meta.outputs.tag }}
          build-args: |
            NEXT_PUBLIC_APP_URL=https://portal.satuitsupply.com

  deploy:
    name: Deploy to ECS
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: prod
    steps:
      - name: Configure AWS credentials (prod)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::095194426970:role/gha-app-deploy-prod
          aws-region: ${{ env.AWS_REGION }}

      - name: Get current task definition
        id: current-task
        run: |
          aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --query 'services[0].taskDefinition' \
            --output text > current-task-def-arn.txt
          
          aws ecs describe-task-definition \
            --task-definition $(cat current-task-def-arn.txt) \
            --query 'taskDefinition' \
            --output json > task-def.json
          
          # Clean fields that can't be in a RegisterTaskDefinition call
          jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)' \
            task-def.json > clean-task-def.json

      - name: Update image in task definition
        id: new-task-def
        run: |
          IMAGE="${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ needs.build-and-push.outputs.image_tag }}"
          
          jq --arg IMAGE "$IMAGE" \
            '.containerDefinitions[0].image = $IMAGE' \
            clean-task-def.json > new-task-def.json
          
          echo "Updated image to: $IMAGE"

      - name: Register new task definition
        id: register
        run: |
          ARN=$(aws ecs register-task-definition \
            --cli-input-json file://new-task-def.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "arn=$ARN" >> "$GITHUB_OUTPUT"
          echo "Registered: $ARN"

      - name: Update ECS service
        run: |
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --task-definition ${{ steps.register.outputs.arn }} \
            --force-new-deployment
          
          echo "Deployment started. Waiting for service stability..."

      - name: Wait for deployment
        run: |
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }}
          
          echo "Service is stable."

      - name: Smoke test
        run: |
          for i in 1 2 3 4 5; do
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://portal.satuitsupply.com/api/health || true)
            if [ "$STATUS" = "200" ]; then
              echo "Health check passed (attempt $i)"
              exit 0
            fi
            echo "Attempt $i: got $STATUS, retrying in 10s..."
            sleep 10
          done
          echo "Health check failed after 5 attempts"
          exit 1
